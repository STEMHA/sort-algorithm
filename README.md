## 排序算法比较
|排序算法|平均时间复杂度|最佳时间复杂度|最坏时间复杂度|空间复杂度|
|:-|:-|:-|:-|:-|
|冒泡排序|O(n<sup>2</sup>)|O(n)|O(n<sup>2</sup>|O(1)|
|选择排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|
|插入排序|O(n<sup>2</sup>)|O(n)|O(n<sup>2</sup>)|O(1)|
|快速排序|O(n log n)|O(n log n)|O(n<sup>2</sup>)|O(log n)|


## 冒泡排序





## 选择排序




## 快速排序
[快速排序.cpp](./快速排序.cpp)  
`快速排序算法（quicksort）`：
- 发明者：英国计算机科学家，1980年图灵奖得主C.A.R.Hoare于1960年发明。
- 分治法策略（Divide and conquer）的典型应用

- 实际应用中的首选算法
  - 易于实现，代码结构紧凑简练
  - 对于通常按照规律随机分布的输入序列，快排实际的平均运行时间比同类算法更少
### 算法思路
使用分治法策略来把一个序列（list）分为两个子序列（sub-lists）。
1. 首先从数列中挑出一个元素，并将这个元素称为`基准或轴点（pivot）`。
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为`分区（partition）操作`。
3. 之后，在子序列中继续重复这个方法，直到最后整个数据序列排序完成。  
### 实现思路
构造轴点/快速划分算法（quick partitioning）  
在array区间[low,high]内构造出一个轴点
1. 取首元素array[low]作为候选，将其从向量中取出备份到tmp,在向量中腾出的空闲单元用于其他元素的位置调整。 
2. 不断试图移动low和high，使其相互靠拢。  
  2.1 移动过程中要保证low左侧的元素均不大于tmp  
  2.2 移动过程中要保证high右侧的元素均不小于tmp
3. 当low和high彼此重合时候，只需要将备份的tmp回填到重合的位置，则array[low=high]=tmp就称为了名副其实的轴点。
4. 然后以轴点为界，递归地对前后子向量实施快速排序；子向量的排序结构就地返回之后，原向量的整体排序完成。


平均时间复杂度（O(n log n)）

最坏时间复杂度（O(n<sup>2</sup>)）
原因：    
- 虽然快排划分出的子任务彼此独立，且规模综合保持渐进不变，但是不能保证两个子任务的规模大体相当，甚至可能极不平衡。  
- 分治策略高效实现的两个必要条件之一——子任务规模接近——无法保证
- 比如每次选择的最左端的元素，对于完全（或者几乎完全）有序的输入向量，每次（或者几乎每次）划分的结果都是1和n-1。

降低最坏情况概率：  
- 随机法：划分的时候在快速划分算法入口加一个swap(array[low],array[low+rand%(high-low+1)])。这样使得后续的处理等同于随机选择一个候选轴点。  
- 三者取中法：从待排序的向量中任取三个元素，将数值居中者作为候选轴点。  

空间复杂度（O(log n)）
辅助空间 log n次



## 堆排序




## 希尔排序



## 归并排序


## 堆排序



## 计数排序



## 桶排序



## 基数排序





## 参考资料
十大经典排序算法 https://zhuanlan.zhihu.com/p/41923298  
数据结构 邓俊辉
